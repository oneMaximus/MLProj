from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import yfinance as yf
import ta as ta
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

# Fetch S&P 500 data and prepare it
data = yf.download('^GSPC', start='2018-01-01', end='2023-01-01')

close_prices = data['Close'].squeeze()
high_prices = data['High'].squeeze()
low_prices = data['Low'].squeeze()
volume = data['Volume'].squeeze()

# Define all features
price_trend_features = ['SMA', 'EMA', 'WMA', 'MACD', 'Parabolic_SAR', 'Ichimoku']
momentum_features = ['RSI', 'Stochastic_Oscillator', 'ROC', 'MOM', 'Williams_R']
volatility_features = ['Bollinger_Mavg', 'ATR']
volume_features = ['OBV', 'Accum_Dist', 'MFI', 'VWAP']

# Calculate Price & Trend Indicators
data['SMA'] = ta.trend.sma_indicator(close_prices, window=9)
data['EMA'] = ta.trend.ema_indicator(close_prices, window=9)
data['WMA'] = ta.trend.wma_indicator(close_prices, window=9)
data['MACD'] = ta.trend.macd_diff(close_prices)
data['Parabolic_SAR'] = ta.trend.psar_down_indicator(high_prices, low_prices, close_prices)
data['Ichimoku'] = ta.trend.ichimoku_a(high_prices, low_prices)

data['RSI'] = ta.momentum.rsi(close_prices, window=9)
data['Stochastic_Oscillator'] = ta.momentum.stoch(high_prices, low_prices, close_prices)
data['ROC'] = ta.momentum.roc(close_prices, window=9)
data['MOM'] = ta.momentum.roc(close_prices, window=9)
data['Williams_R'] = ta.momentum.williams_r(high_prices, low_prices, close_prices)

data['Bollinger_Mavg'] = ta.volatility.bollinger_mavg(close_prices)
data['ATR'] = ta.volatility.average_true_range(high_prices, low_prices, close_prices)

data['OBV'] = ta.volume.on_balance_volume(close_prices, volume)
data['Accum_Dist'] = ta.volume.acc_dist_index(high_prices, low_prices, close_prices, volume)
data['MFI'] = ta.volume.money_flow_index(high_prices, low_prices, close_prices, volume, window=9)
data['VWAP'] = ta.volume.volume_weighted_average_price(high_prices, low_prices, close_prices, volume, window=9)

# Drop NaN values (due to indicator calculations)
data.dropna(inplace=True)

# Create Lag Features
data['Lag_1'] = data['Close'].shift(1)
data.dropna(inplace=True)  # Drop rows with NaN values from lagging

# Prepare feature matrix and target variable based on found feature importance
X = data[['SMA', 'VWAP', 'Bollinger_Mavg', 'Ichimoku']]
y = data['Close']

# Split data: 60% Train, 20% Validation, 20% Test
total_size = len(data)
train_size = int(total_size * 0.6)
val_size = int(total_size * 0.2)

X_train = X[:train_size]
y_train = y[:train_size]
X_val = X[train_size:train_size + val_size]
y_val = y[train_size:train_size + val_size]
X_test = X[train_size + val_size:]
y_test = y[train_size + val_size:]

# Scale features (X) and target (Y) for train, val, and test
scaler_X = StandardScaler()
scaler_Y = StandardScaler()

# Fit scaler on training data only, transform all sets
X_train_scaled = scaler_X.fit_transform(X_train)
X_val_scaled = scaler_X.transform(X_val)
X_test_scaled = scaler_X.transform(X_test)
y_train_scaled = scaler_Y.fit_transform(y_train.values.reshape(-1, 1)).ravel()
y_val_scaled = scaler_Y.transform(y_val.values.reshape(-1, 1)).ravel()
y_test_scaled = scaler_Y.transform(y_test.values.reshape(-1, 1)).ravel()

# Train Linear Regression Model
modelLR = LinearRegression()
modelLR.fit(X_train_scaled, y_train_scaled)

# Predict on validation and test sets
y_pred_val_scaled = modelLR.predict(X_val_scaled)
y_pred_val = scaler_Y.inverse_transform(y_pred_val_scaled.reshape(-1, 1)).ravel()

# Evaluate initial model (on validation set)
val_mse = mean_squared_error(y_val, y_pred_val)
val_r2 = r2_score(y_val, y_pred_val)
print(f"Initial Model MSE (Validation, Linear Regression): {val_mse:.4f}")
print(f"Initial Model R^2 (Validation, Linear Regression): {val_r2:.4f}")

# Predict for test set (initial model)
y_pred_test_scaled = modelLR.predict(X_test_scaled)
y_pred_test = scaler_Y.inverse_transform(y_pred_test_scaled.reshape(-1, 1)).ravel()
y_test_actual = y_test.values  # Actual test prices

# Evaluate initial model (on test set)
test_mse = mean_squared_error(y_test_actual, y_pred_test)
test_r2 = r2_score(y_test_actual, y_pred_test)

# Print Results
indicator_list = [col[0] if isinstance(col, tuple) else col for col in X.columns]

print(f"Model MSE ({indicator_list}): {test_mse:.4f}")
print(f"Model RÂ² ({indicator_list}): {test_r2:.4f}")

# =============================================================================
# Visualization: Actual vs. Predicted Prices
# =============================================================================
plt.figure(figsize=(12, 6))
plt.plot(y_test_actual, label='Actual Price', marker='o', linestyle='solid')
plt.plot(y_pred_test, label='Predicted Price (Linear Regression)', linestyle='dashed', marker='x')
plt.xlabel('Date')
plt.ylabel('Stock Price')
plt.title('Linear Regression: Actual vs Predicted S&P 500 Prices')
plt.legend()
plt.grid(True)
plt.show()
